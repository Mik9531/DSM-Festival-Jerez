/ *
* EaselJS
* Visita http://createjs.com/ de documentación, actualizaciones y ejemplos.
*
* Derechos de autor (c) 2011 gskinner.com, inc.
* 
* Distribuido bajo los términos de la licencia MIT.
* http://www.opensource.org/licenses/mit-license.html
*
* Este aviso se incluye en todas las copias o partes sustanciales del Software.
* /
( Función ( g ) { var  c = función () { tiro " UID no se pueden crear instancias " ;}; c . _nextID = 0 ; c . Obtener = función () { retorno  c . _nextID ++ }; G . UID = c }) (CreateJS || (CreateJS = {})); var CreateJS; ( función ( g ) { var  c = función () { lanzar " Ticker no se pueden crear instancias. " ;}; c . useRAF = nula ; c . _listeners = nula ; c . _pauseable = nula ; c . _paused = false ; c . _inited = false ; c . _startTime = 0 ; c . _pausedTime = 0 ; c . _ticks = 0 ; c . _pausedTicks = 0 ; c . _interval = 50 ; c . _lastTime = 0 ; c . _times = nula ; c . _tickTimes = nula ; c . _rafActive = false ; c . _timeoutID = nula ; c . addListener = función ( una , k ) {a ! = nula && ( c . _inited || c . init (), c . removeListener (una ), c . _pauseable [ c . _listeners . de longitud ] = k == nula ? verdad : k, c . _listeners . empujan (a))}; c . init = función () { c . _inited = verdadero ; c . _times =
[]; c . _tickTimes = []; c . _pauseable = []; c . _listeners = []; c . _times . empuje ( c . _lastTime = c . _startTime = c . _getTime ()); c . setInterval ( c . _interval )}; c . removeListener = función ( un ) { var k = c . _listeners ; k && (un = k . indexOf (a), un =! - 1 && ( k . empalmar (a, 1 ), c . _pauseable . empalmar (a, 1 )))}; c . removeAllListeners = función () { c . _listeners = []; c . _pauseable = []}; c . setInterval = función ( un ) { c . _interval = a; c . _inited && c . _setupTick ()}; c . getInterval = función () { retorno  c . _interval }; c . setFPS = función ( un ) { c . setInterval ( 1E3 / a)}; c . getFPS = función () { volver  1E3 / c . _interval };
c . getMeasuredFPS = función ( un ) { si ( c . _times . de longitud < 2 ) de retorno - 1 , un == nula && (a = c . getFPS () | 0 ); un = Math . min ( c . _times . de longitud - 1 , a); retorno  1E3 / (( c . _times [ 0 ] - c . _times [a]) / a)}; c . setPaused = función ( un ) { c . _paused = a}; c . getPaused = función () { retorno  c . _paused }; c . getTime = función ( un ) { volver  c . _getTime () - c . _startTime - (a ? c . _pausedTime : 0 )}; c . GetTicks = función ( un ) { retorno  c . _ticks - (un ? c . _pausedTicks : 0 )}; c . _handleAF = función () { c . _rafActive = false ; c . _setupTick (); c . _getTime () - c . _lastTime > = ( c . _interval - 1 ) * 0.97 && c . _tick ()}; c . _handleTimeout =
la función () { c . timeoutID = nula ; c . _setupTick (); c . _tick ()}; c . _setupTick = función () { si ( ! ( c . _rafActive || c . timeoutID ! = nulo )) { si ( c . useRAF ) { var un = ventana . requestAnimationFrame || ventana . webkitRequestAnimationFrame || ventana . mozRequestAnimationFrame || ventana . oRequestAnimationFrame || ventana . msRequestAnimationFrame ; si (a) { un ( c . _handleAF ); c . _rafActive = verdadero ; devolver }} c . timeoutID = setTimeout ( c . _handleTimeout , c . _interval )}}; c . _tick = función () { var un = c . _getTime (); c . _ticks ++ ; var k = un - c . _lastTime , b = c . _paused ; b && ( c . _pausedTicks ++ ,
c . _pausedTime + = k); c . _lastTime = a; para ( var d = c . _pauseable , e = c . _listeners . rebanada (), f = e ? e . Longitud : 0 , h = 0 ; h < f; h ++ ) { var i = E [h]; i == nula || b && d [h] || ( I . Tictac ? I . Garrapatas (k, b) : i instanceOf  Función && i (k, b))} para ( c . _tickTimes . Unshift ( c . _getTime () - A); c . _tickTimes . De longitud > 100 ;) c . _tickTimes . pop (); para ( c . _times . unshift (a); c . _times . de longitud > 100 ;) c . _times . pop ()}; var b = ventana . rendimiento && ( rendimiento . Ahora || rendimiento . mozNow || rendimiento . Msnow || rendimiento . oNow || rendimiento . webkitNow ); c . _getTime = función () { retorno b && b . llamar ( el rendimiento ) ||
( Nueva  fecha ). getTime ()}; g . Ticker = c}) (CreateJS || (CreateJS = {})); ( función ( g ) { var  c = función ( una , k , b , d , c , f , h , i , j ) { esto . Inicializar (a, k, b, d, c, f, h, i, j)}, b = c . prototipo ; b . stageX = 0 ; b . stageY = 0 ; b . rawX = 0 ; b . rawy = 0 ; b . tipo = nula ; b . nativeEvent = nula ; b . onMouseMove = nula ; b . onMouseUp = nula ; b . diana = nula ; b . pointerID = 0 ; b . primaria = false ; b . inicializar = función ( una , k , b , d , c , f , h , i , j ) { esto . tipo = a; esto . stageX = k; esto . stageY = b; esto . objetivo = d; esto . nativeEvent = c; esto . pointerID = f; esto . primarias = h; esto . rawX = i == nula ? k : i; esto . rawy = j == nula ? b : j}; b . clon = función () { vuelvo  nuevos  c ( este . tipo , este . stageX , este . stageY ,
este . orientar , este . nativeEvent , este . pointerID , este . primario , este . rawX , este . rawy )}; b . toString = función () { retorno " [MouseEvent (type = " + esto . Tipo + " stageX = " + esto . stageX + " stageY = " + esto . stageY + " )] " }; g . MouseEvent = c}) (CreateJS || (CreateJS = {})); ( función ( g ) { var  c = función ( un , k , b , d , c , f ) { esto . Inicializar (a, k, b , d, c, f)}, b = c . prototipo ; c . identidad = nula ; c . DEG_TO_RAD = Math . PI / 180 ; b . una = 1 ; b . b = 0 ; b . c = 0 ; b . d = 1 ; b . tx = 0 ; b . ty = 0 ; b . alpha = 1 ; b . sombra = nula ; b . compositeOperation = nula ; b . inicializar = función ( una , k , b , d , c , f ) { si (a ! = nula ) este . un = a; esto . b = k || 0 ; esto . c = b || 0 ; si (d ! = nula ) este . d = d; esto . tx = c || 0 ; esto . ty = f || 0 ; devolver  esta }; b . anteponer = función ( una , k , b , d , c , f ) { var h = presente . tx ; si (a ! = 1 || k =! 0 || b =! 0 || d =! 1 ) { var i = presente . una , j = presente . c ; esto . un = i * un + este . b * b; este . b = i * k + este . b * d; esto . c = j * un + esto . d *
segundo; este . d = j * k + esto . d * d} presente . tx = h * un + este . Ty * b + c; este . ty = h * k + este . Ty * d + f; devolver  esta }; b . append = función ( un , k , b , d , c , f ) { var h = esta . un , i = presente . b , j = presente . c , l = presente . d ; este . un = un * h + k * j; este . b = un * i + k * l; este . c = b * h + d * j; este . d = b * i + d * l; este . tx = c * h + f * j + esto . tx ; este . ty = c * i + f * l + esto . dad ; devolver  esta }; b . prependMatrix = función ( un ) { esto . Anteponer ( un . un , una . b , un . c , una . d , una . tx , una . ty ); este . prependProperties ( un . alfa , una . sombra , una . compositeOperation ); devolver  esta }; b . appendMatrix = función ( un ) { esto . añadir ( un . un , una . b , un . c , un . d , un . tx , un . ty ); este . appendProperties ( un . alpha ,
un . sombra , una . compositeOperation ); devolver  esta }; b . prependTransform = función ( una , k , b , d , e , f , h , i , j ) { si (e % 360 ) var l = e * c . DEG_TO_RAD , e = Math . cos (l), l = Math . pecado (l); otra cosa e = 1 , l = 0 ; si (i || j) de este . tx - = i, este . Ty - = j; f || h ? (f * = c . DEG_TO_RAD , h * = c . DEG_TO_RAD , este . prepend (e * b, l * b, - l * d, e * d, 0 , 0 ), este . anteponer ( Math . cos (h ), Math . pecado (h), - Matemáticas . pecado (f), Math . cos (f), a, k)) : este . Anteponer (e * b, l * b, - l * d, e * d, a, k); devolver  esta }; b . appendTransform = función ( una , k , b , d , e , f , h , i , j ) { si (e % 360 ) var l = e * c . DEG_TO_RAD , e = Math . cos (l), l = Math . pecado (l); otra cosa e = 1 , l = 0 ; f ||
h ? (f * = c . DEG_TO_RAD , h * = c . DEG_TO_RAD , este . append ( Math . cos (h), Math . pecado (h), - Matemáticas . pecado (f), Math . cos (f), una, k), esta . anexar (e * b, l * b, - l * d, e * d, 0 , 0 )) : este . append (e * b, l * b, - l * d, e * d, a, k); si (i || j) de este . tx - = i * esto . un + j * este . c , este . Ty - = i * esto . b + j * esto . d ; devolver  esta }; b . Girar = función ( un ) { var k = Math . cos (a), un = Math . pecado (a), b = presente . una , d = presente . c , c = presente . tx ; este . un = b * k - este . b * a; este . b = b * a + esto . b * k; este . c = d * k - este . d * a; este . d = d * un + esto . d * k; este . tx = c * k - este . ty * a; este . ty = c * un + este . ty * k; devolver  esta }; b . oblicuidad = función ( una , k ) {a * = c . DEG_TO_RAD ; k * =
c . DEG_TO_RAD ; este . append ( Math . cos (k), Math . pecado (k), - Matemáticas . sen (a), Math . cos (a), 0 , 0 ); devolver  esta }; b . escala = función ( una , k ) { esto . un * = a; este . d * = k; este . tx * = a; este . Ty * = k; devolver  esta }; b . traducir = función ( un , k ) { esto . tx + = a; este . ty + = k; devolver  esta }; b . identidad = función () { esto . alfa = esta . un = esta . d = 1 ; este . b = presente . c = esta . tx = esta . ty = 0 ; este . sombra = presente . compositeOperation = nula ; devolver  esta }; b . Invertir = función () { var un = presente . una , k = esta . b , b = presente . c , d = presente . d , c = presente . tx , f = un * d - k * b; este . un = d / f; este . b = - k / f; este . c = - b / f; este . d = un / f; este . tx = (b *
este . Ty - d * c) / f; este . ty = - (a * esto . Ty - k * c) / f; devolver  esta }; b . isIdentity = función () { volver  este . tx == 0 && este . ty == 0 && este . un == 1 && este . b == 0 && esto . c == 0 && este . d == 1 }; b . descomponer = función ( un ) {a == nula && (a = {}); un . x = esta . tx ; un . y = esta . dad ; un . scaleX = Math . sqrt ( este . un * esto . un + este . b * esto . b ); un . scaleY = Math . sqrt ( este . c * esto . c + esto . d * esto . d ); var k = Math . atan2 ( - este . c , este . d ), b = Math . atan2 ( este . b , presente . una ); k == b ? ( Un . Rotación = b / c . DEG_TO_RAD , este . Un < 0 && esto . D > = 0 && ( un . Rotación + = una . Giro <= 0 ? 180 : - 180 ), una . SkewX = una . SkewY = 0 ) : ( a . skewX = k / c . DEG_TO_RAD ,
un . skewY = b / c . DEG_TO_RAD ); volver a}; b . Fecha = función ( una , k , b , d , c , f , h , i , j ) { esto . inicializar (a, k, b, d, c, f); este . alfa = h || 1 ; este . sombra = i; este . compositeOperation = j; devolver  esta }; b . appendProperties = función ( un , k , b ) { esto . alfa * = a; este . sombra = k || este . sombra ; este . compositeOperation = b || este . compositeOperation ; devolver  esta }; b . prependProperties = función ( un , k , b ) { esto . alfa * = a; este . sombra = presente . sombra || k; este . compositeOperation = presente . compositeOperation || segundo; devolver  esta }; b . clon = función () { var a = nuevos  c ( este . una , este . b ,
this.c, this.d, this.tx, this.ty); a.shadow = this.shadow; a.alpha = this.alpha; a.compositeOperation = this.compositeOperation; volver a}; b.toString = function () {return "[Matrix2D (a =" + + this.a "b =" + + this.b "c =" + + this.c "d =" + + this.d "tx =" + + this.tx "ty = "+ + this.ty")] "}; c.identity = nuevos c (1,0,0,1,0,0); g.Matrix2D = c}) (CreateJS || (CreateJS = {})); (function (g) {var c = function (a, k) {this.initialize (a, k)}, b = c.prototype; bx = 0; por = 0; b.initialize = function (a, k) {this.x = a nula == 0:? a; this.y k = 0 == null:? k}; b.clone = function () {return nuevos c (this.x, this.y)}; b.toString = function () {return "[punto (x =" + this.x + "y =" + ") this.y +]"}; g.Point = c}) (CreateJS || (CreateJS = {} )); (función (g) {var c = función (a, k, b, d) {this.initialize (a, k, b, d)}, b = c.prototype; bx = 0; por = 0 ; b.width = 0; b.height = 0; b.initialize = función (a, k, b, d) {this.x = a nulo == 0: a; this.y = k == null?? 0: k; this.width = b == null 0:? b = d; this.height == null 0:? d}; b.clone = function () {return new c (this.x, this.y , this.width, this.height)}; b.toString = function () {return "[Rectángulo (x =" + this.x + "y =" + + this.y "width =" + + this.width "height = "+ + this.height")] "}; g.Rectangle = c}) (CreateJS || (CreateJS = {})); (función (g) {var c = function (a, b, m, d) { this.initialize (a, b, m, d)}, b = c.prototype; c.identity = null; B.Color = null; b.offsetX = 0; b.offsetY = 0; b.blur = 0; b.initialize = function (a, b, m, d) {this.color = a; this.offsetX = b; this.offsetY = m; this.blur = d}; b.toString = function () {return " [Shadow] "}; b.clone = function () {return new c (this.color, this.offsetX, this.offsetY, this.blur)}; c.identity = new c (" transparentes ", 0,0 , 0); g.Shadow = c}) (CreateJS || (CreateJS = {})); (función (g) {var c = función (a) {this.initialize (a)}, b = c.prototype ; b.complete = true; b.onComplete = null; b._animations = null; b._frames = null; b._images = null; b._data = null; b._loadCount = 0; b._frameHeight = 0; b ._frameWidth = 0; b._numFrames = 0; b._regX = 0; b._regY = 0; b.initialize = function (a) {var b, m, d; if (! a = null) {if (una .images && (m = a.images.length)> 0) {d = this._images = []; para (b = 0, b <m; b ++) {var c = a.images [b]; si (typeof c == "cadena") {var f = c, c = nueva imagen; c.src = f} d.push (c);! if (! c.getContext && c.complete) this._loadCount ++, this.complete =
falsa , la función ( un ) { c . onload = función () { una . _handleImageLoad ()}} ( este )}} si ( un . marcos ! = nulo ) si ( un . marcos  instanceof  array ) { esto . _frames = []; d = una . marcos ; para (b = 0 , m = d . de longitud ; b < m; b ++ ) f = d [b], este . _frames . empuje ({imagen : este . _images [f [ 4 ] ? f [ 4 ] : 0 ], rect : nueva  g.Rectangle (f [ 0 ], f [ 1 ], f [ 2 ], f [ 3 ]), regX : f [ 5 ] || 0 , REGY : f [ 6 ] || 0 })} demás m = un . marcos , este . _frameWidth = m . anchura , este . _frameHeight = m . altura , este . _regX = m . regX || 0 , este . _regY = m . REGY || 0 , este . _numFrames = m . contar , este . _loadCount == 0 && este . _calculateFrames (); si ((m = un . animaciones ) ! = nula ) { esto . _animations =
[]; este . _data = {}; para ( var h en m) {a = {nombre : h}; f = m [h]; si ( isNaN (f)) si (f instanceof  array ) { una . Frecuencia = f [ 3 ]; un . junto = f [ 2 ]; d = una . marcos = []; para (b = f [ 0 ]; b <= f [ 1 ]; b ++ ) d . empuje (b)} lo demás  una . Frecuencia = f . frecuencia , un . junto = f . siguiente , b = f . marcos , d = a . marcos = ! isNaN (b) ? [b] : b . rebanada ( 0 ); otra cosa d = una . marcos = [f]; un . junto = d . longitud < 2 || un . próximos == falsa ? nula : una . junto == nula || un . próximos == verdad ? h : una . siguiente ; si ( ! una . frecuencia ) una . Frecuencia = 1 ; este . _animations . pulsador (h); este . _data [h] = a}}}}; b . getNumFrames = función ( un ) { volver a == nula ? este . _frames ? este . _frames . longitud : este . _numFrames :
(a = esta . _data [a], un == nulo ? 0 : un . marcos . de longitud )}; b . getAnimations = función () { regresan  este . _animations . rebanada ( 0 )}; b . getAnimation = función ( un ) { volver  este . _data [a]}; b . GetFrame = función ( un ) { volver  este . completar && este . _frames && (frame = esta . _frames [a]) ? marco : nulo }; b . toString = función () { retorno " [spritesheet] " }; b . clon = función () { var un = nueva  c ; un . completa = presente . completar ; un . _animations = presente . _animations ; un . _frames = presente . _frames ; un . _images = presente . _images ; un . _data = presente . _data ; un . _frameHeight = presente . _frameHeight ; un . _frameWidth = presente . _frameWidth ;
un . _numFrames = presente . _numFrames ; un . _loadCount = presente . _loadCount ; volver a}; b . _handleImageLoad = función () { si ( - este . _loadCount == 0 ) esta . _calculateFrames (), este . completa = cierto , este . onComplete && esto . onComplete ()}; b . _calculateFrames = función () { si ( ! ( este . _frames || esto . _frameWidth == 0 )) { esto . _frames = []; para ( var un = 0 , b = presente . _frameWidth , m = presente . _frameHeight , c = 0 , e = presente . _images ; c < e . de longitud ; c ++ ) { a ( var f = e [c], h = ( f . de ancho + 1 ) / b | 0 , i = ( f . de altura + 1 ) / m | 0 , i = presente . _numFrames > 0 ? Math . min ( esta . _numFrames - a, h * i) : h * i, j = 0 ; j < i; j ++ ) este . _frames . empuje ({imagen : f,
rect : nueva  g.Rectangle (j % h * b, (j / h | 0 ) * m, b, m), regX : este . _regX , Regy : este . _regY }), un + = i} esta . _numFrames = a}}; g . Spritesheet = c}) (CreateJS || (CreateJS = {})); ( función ( g ) { función  c ( un , b , c ) { esto . F = a; esto . Params = b; esto . Ruta = c == nula ? verdad : c} c . prototipo . exec = función ( un ) { esto . f . aplicar (a, esta . params )}; var  b = función () { esto . initialize ()}, a = b . prototipo ; b . getRGB = función ( un , b , c , e ) {a ! = nulo && c == nula && (e = b, c = un y 255 , b = un >> 8 y 255 , un = un >> 16 y 255 ); retorno e == nula ? " rgb ( " + un + " , " + b + " , " + c + " ) " : " RGBA ( " + un + " , " + b + " , " + c + " , " + e + " ) " }; b . getHSL = función ( un , b , c , e ) { retorno e == nula ? " HSL ( " + un % 360 + " , " + b + " %, " + c + " %) " : " HSLA ( " + un % 360 + " , " + b + " %, " + c + " %, " + e + " ) " }; b . BASE_64 = {A : 0 , B : 1 , C : 2 , D : 3 , E : 4 , M : 5 , G : 6 , H : 7 , I : 8 ,
J : 9 , K : 10 , L : 11 , M : 12 , N : 13 , O : 14 , P : 15 , Q : 16 , I : 17 , S : 18 , T : 19 , T : 20 , V : 21 , W : 22 , X : 23 , Y : 24 , Z : 25 , un : 26 , B : 27 , c : 28 , d : 29 , e : 30 , f : 31 , g : 32 , h : 33 , i : 34 , j : 35 , k : 36 , l : 37 , m : 38 , n : 39 , O : 40 , p : 41 , q : 42 , r : 43 , s : 44 , t : 45 , T : 46 , v : 47 , w : 48 , x : 49 , y : 50 , z : 51 , 0 : 52 , 1 : 53 , 2 : 54 , 3 : 55 , 4 : 56 , 5 : 57 , 6 : 58 , 7 : 59 , 8 : 60 , 9 : 61 , " + " : 62 , " / " : 63 }; b . STROKE_CAPS_MAP = [ " a tope " , " redondo " , " plaza " ]; b . STROKE_JOINTS_MAP = [ " mitra " , " redondo " , " cónico " ]; b . _ctx = ( g . createCanvas ? g . createCanvas () : documento . createElement ( " tela " )). getContext ( " 2d " ); b . beginCmd = nueva  c ( b . _ctx . beginPath , [], falsa );
b . fillCmd = nueva  c ( b . _ctx . llenar , [], falsa ); b . strokeCmd = nueva  c ( b . _ctx . ictus , [], falsa ); un . _strokeInstructions = nula ; un . _strokeStyleInstructions = nula ; un . _fillInstructions = nula ; un . _instructions = nula ; un . _oldInstructions = nula ; un . _activeInstructions = nula ; un . _active = false ; un . _dirty = false ; un . inicializar = función () { esto . claro (); este . _ctx = b . _ctx }; un . dibujar = función ( un ) { esto . _dirty && este . _updateInstructions (); para ( var b = presente . _instructions , c = 0 , e = b . de longitud ; c < e; c ++ ) b [c]. exec (a)}; un . drawAsPath = función ( un ) { esto . _dirty && este . _updateInstructions ();
para ( var b, c = presente . _instructions , e = 0 , f = c . de longitud ; e < ; f e ++ ((b) = . c [e]) ruta || e == 0 ) && b . exec (a)}; un . moveTo = función ( un , b ) { esto . _activeInstructions . empuje ( nueva  c ( este . _ctx . moveTo , [a, b])); devolver  esta }; un . lineTo = función ( un , b ) { esto . _dirty = presente . _active = verdadero ; este . _activeInstructions . empuje ( nueva  c ( este . _ctx . lineTo , [a, b])); devolver  esta }; un . arcto = función ( un , b , d , e , f ) { esto . _dirty = presente . _active = verdadero ; este . _activeInstructions . empuje ( nueva  c ( este . _ctx . arcto , [a, b, d, e, f])); devolver  esta }; un . arco = función ( un , b , d , e , f , h ) { esto . _dirty = presente . _active =
verdadera ; h == nula && (h = false ); este . _activeInstructions . empuje ( nueva  c ( este . _ctx . arco , [a, b, d, e, f, h])); devolver  esta }; un . quadraticCurveTo = función ( un , b , d , e ) { esto . _dirty = presente . _active = verdadero ; este . _activeInstructions . empuje ( nueva  c ( este . _ctx . quadraticCurveTo , [a, b, d, e])); devolver  esta }; un . bezierCurveTo = función ( un , b , d , e , f , h ) { esto . _dirty = presente . _active = verdadero ; este . _activeInstructions . empuje ( nueva  c ( este . _ctx . bezierCurveTo , [a, b, d, e, f, h])); devolver  esta }; un . rect = función ( un , b , d , e ) { esto . _dirty = presente . _active = verdadero ; este . _activeInstructions . empuje ( nueva  c ( este . _ctx . rect ,
[a, b, d, e])); devolver  esta }; un . closePath = función () { si ( este . _active ) este . _dirty = cierto , este . _activeInstructions . empuje ( nueva  c ( este . _ctx . closePath , [])); devolver  esta }; un . claro = función () { esto . _instructions = []; este . _oldInstructions = []; este . _activeInstructions = []; este . _strokeStyleInstructions = presente . _strokeInstructions = presente . _fillInstructions = nula ; este . _active = presente . _dirty = false ; devolver  esta }; un . beginFill = función ( un ) { esto . _active && este . _newPath (); este . _fillInstructions = una ? [ Nueva  c ( este . _setProp , [ " FillStyle " , a], falsa )] : nula ;
devolver  esta }; un . beginLinearGradientFill = función ( un , b , d , e , f , h ) { esto . _active && este . _newPath (); d = presente . _ctx . createLinearGradient (d, e, f, h), e = 0 ; para (f = un . de longitud ; e < f; e ++ ) d . addColorStop (b [e], una [e]); este . _fillInstructions = [ nuevo  c ( este . _setProp , [ " fillStyle " , d], falsa )]; devolver  esta }; un . beginRadialGradientFill = función ( un , b , d , e , f , h , i , j ) { esto . _active && este . _newPath (); d = presente . _ctx . createRadialGradient (d, e, f, h, i, j), e = 0 ; para (f = un . de longitud ; e < f; e ++ ) d . addColorStop (b [e], una [e]); este . _fillInstructions = [ nuevo  c ( este . _setProp , [ " fillStyle " ,
d], falsa )]; devolver  esta }; un . beginBitmapFill = función ( un , b ) { esto . _active && este . _newPath (); var d = presente . _ctx . createPattern (a, b || " " ); este . _fillInstructions = [ nuevo  c ( este . _setProp , [ " fillStyle " , d], falsa )]; devolver  esta }; un . endFill = función () { volver  este . beginFill ()}; un . setStrokeStyle = función ( una , m , d , e ) { esto . _active && este . _newPath (); este . _strokeStyleInstructions = [ nuevo  c ( este . _setProp , [ " anchoLinea " , un == nula ? " 1 " : a], falsa ), nueva  c ( este . _setProp , [ " lineCap " , m == nula ? " a tope " : isNaN (m) ? m : b . STROKE_CAPS_MAP [m]], falsa ), nuevos  c ( esta . _setProp ,
[ " LineJoin " , d == nula ? " Mitra " : isNaN (d) ? d : b . STROKE_JOINTS_MAP [d]], falsa ), nuevos  c ( este . _setProp , [ " MiterLimit " , e == nula ? " 10 " : e], falsa )]; devolver  esta }; un . beginStroke = función ( un ) { esto . _active && este . _newPath (); este . _strokeInstructions = una ? [ Nueva  c ( este . _setProp , [ " StrokeStyle " , a], falsa )] : nula ; devolver  esta }; un . beginLinearGradientStroke = función ( un , b , d , e , f , h ) { esto . _active && este . _newPath (); d = presente . _ctx . createLinearGradient (d, e, f, h), e = 0 ; para (f = un . de longitud ; e < f; e ++ ) d . addColorStop (b [e], una [e]); este . _strokeInstructions = [ nuevo  c ( este . _setProp ,
[ " StrokeStyle " , d], falsa )]; devolver  esta }; un . beginRadialGradientStroke = función ( un , b , d , e , f , h , i , j ) { esto . _active && este . _newPath (); d = presente . _ctx . createRadialGradient (d, e, f, h, i, j), e = 0 ; para (f = un . de longitud ; e < f; e ++ ) d . addColorStop (b [e], una [e]); este . _strokeInstructions = [ nuevo  c ( este . _setProp , [ " strokeStyle " , d], falsa )]; devolver  esta }; un . beginBitmapStroke = función ( un , b ) { esto . _active && este . _newPath (); var d = presente . _ctx . createPattern (a, b || " " ); este . _strokeInstructions = [ nuevo  c ( este . _setProp , [ " strokeStyle " , d], falsa )]; devolver  esta }; un . endStroke =
la función () { esto . beginStroke (); devolver  esta }; un . curveTo = una . quadraticCurveTo ; un . drawRect = una . rect ; un . drawRoundRect = función ( un , b , c , e , f ) { esto . drawRoundRectComplex (a, b, c, e, f, f, f, f); devolver  esta }; un . drawRoundRectComplex = función ( un , b , d , e , f , h , i , j ) { var l = (d < e ? d : e) / 2 , g = 0 , p = 0 , o = 0 , r = 0 ; f < 0 && (f * = g = - 1 ); f > l && (f = l); h < 0 && (h * = p = - 1 ); h > l && (h = l); i < 0 && (i * = O = - 1 ); i > l && (i = l); j < 0 && (j * = r = - 1 ); j > l && (j = l); este . _dirty = presente . _active = verdadero ; var l = esta . _ctx . arcto , q = presente . _ctx . lineTo ; este . _activeInstructions . empuje ( nuevos  c ( este . _ctx . moveTo , [a + d - h, b]),
nuevos  c (l, [a + d + h * p, b - h * p, a + d, b + h, h]), nuevos  c (q, [a + d, b + e - i]), nuevos  c (l, [a + d + i * o, b + e + i * O, a + d - i, b + e, i]), nuevos  c (q, [a + j, b + e] ), nuevos  c (l, [a - j * r, b + e + j * r, a, b + e - j, j]), nuevos  c (q, [a, b + f]), nueva  c (l, [a - f * g, b - f * g, un + f, b, f]), nueva  c ( este . _ctx . closePath )); devolver  esta }; un . drawCircle = función ( un , b , c ) { esto . arco (a, b, c, 0 , Math . PI * 2 ); devolver  esta }; un . drawEllipse = función ( un , b , d , e ) { esto . _dirty = presente . _active = verdadero ; var f = d / 2 * 0,5522848 , h = e / 2 * 0,5522848 , i = un + d, j = b + e, d = un + d / 2 , e = b + e / 2 ; este . _activeInstructions . empuje ( nueva  c ( este . _ctx . moveTo , [a, e]), nuevos  c ( este . _ctx . bezierCurveTo ,
[a, e - h, d - f, b, d, b]), nueva  c ( este . _ctx . bezierCurveTo , [d + f, b, i, e - h, i, e]), nuevos  c ( este . _ctx . bezierCurveTo , [i, e + h, d + f, j, d, j]), nuevos  c ( este . _ctx . bezierCurveTo , [d - f, j, a, e + h, a, e ])); devolver  esta }; un . drawPolyStar = función ( un , b , d , e , f , h ) { esto . _dirty = presente . _active = verdadero ; f == nula && (f = 0 ); f = 1 - f; h == nula ? h = 0 : h / = 180 / Matemáticas . PI ; var i = Math . PI / e; este . _activeInstructions . empuje ( nueva  c ( este . _ctx . moveTo , [a + Matemáticas . cos (h) * d, b + Matemáticas . pecado (h) * d])); para ( var j = 0 ; j < e; j ++ ) h + = i, f =! 1 && esto . _activeInstructions . empuje ( nueva  c ( este . _ctx . lineTo , [a + Matemáticas . cos (h) * d *
f, b + Matemáticas . pecado (h) * d * f])), h + = i, este . _activeInstructions . empuje ( nueva  c ( este . _ctx . lineTo , [a + Matemáticas . cos (h) * d, b + Matemáticas . pecado (h) * d])); devolver  esta }; un . DECODEPATH = función ( un ) { para ( var c = [ esto . moveTo , este . lineTo , este . quadraticCurveTo , este . bezierCurveTo ], d = [ 2 , 2 , 4 , 6 ], e = 0 , f = una . longitud , h = [], i = 0 , j = 0 , l = b . BASE_64 ; e < f;) { var g = una . charAt (e), p = l [g], o = p >> 3 , r = c [o]; si ( ! r || P y 3 ) tirar " datos de la trayectoria malos (@ " + e + " ): " + g; g = d [o]; o || (i = j = 0 ); h . longitud = 0 ; e ++ ; p = (p >> 2 y 1 ) + 2 ; para (O = 0 ; o < g; o ++ ) { var q = l [ una . charAt (e)], t = q >> 5 ? - 1 : 1 , q = (q y 31 ) << 6 | l [ a . charAt (e + 1 )]; p ==
3 && (q = q << 6 | l [ una . CharAt (e + 2 )]); q = t * q / 10 ; o % 2 ? i = q + = i : j = q + = j; h [o] = q; e + = p} r . aplicar ( este , h)} regreso  esta }; un . clon = función () { var un = nueva  b ; un . _instructions = presente . _instructions . rebanada (); un . _activeInstructions = presente . _activeInstructions . rebanada (); un . _oldInstructions = presente . _oldInstructions . rebanada (); si ( este . _fillInstructions ) una . _fillInstructions = presente . _fillInstructions . rebanada (); si ( este . _strokeInstructions ) una . _strokeInstructions = presente . _strokeInstructions . rebanada (); si ( este . _strokeStyleInstructions ) una . _strokeStyleInstructions = presente . _strokeStyleInstructions . rebanada ();
un . _active = presente . _active ; un . _dirty = presente . _dirty ; un . drawAsPath = presente . drawAsPath ; volver a}; un . toString = función () { retorno " [Gráficos] " }; un . MT = una . moveTo ; un . lt = una . lineTo ; un . a = una . arcto ; un . bt = una . bezierCurveTo ; un . qt = una . quadraticCurveTo ; un . un = un . arco ; un . r = un . rect ; un . cp = una . closePath ; un . c = un . clara ; un . f = una . beginFill ; un . LF = una . beginLinearGradientFill ; un . rf = una . beginRadialGradientFill ; un . bf = una . beginBitmapFill ; un . ef = una . endFill ; un . ss = una . setStrokeStyle ; un . s = una . beginStroke ; un . ls = a . beginLinearGradientStroke ; un . rs = una . beginRadialGradientStroke ; un . bs = una . beginBitmapStroke ;
un . ES = una . endStroke ; un . dr = una . drawRect ; un . rr = una . drawRoundRect ; un . rc = una . drawRoundRectComplex ; un . dc = una . drawCircle ; un . de = una . drawEllipse ; un . dp = una . drawPolyStar ; un . p = una . DECODEPATH ; un . _updateInstructions = función () { esto . _instructions = presente . _oldInstructions . rebanada (); este . _instructions . empuje ( b . beginCmd ); este . _fillInstructions && este . _instructions . empujar . aplicar ( esta . _instructions , este . _fillInstructions ); este . _strokeInstructions && ( este . _instructions . empujar . aplican ( esta . _instructions , este . _strokeInstructions ), este . _strokeStyleInstructions &&
este . _instructions . empujar . aplicar ( esta . _instructions , este . _strokeStyleInstructions )); este . _instructions . empujar . aplicar ( esta . _instructions , este . _activeInstructions ); este . _fillInstructions && este . _instructions . empuje ( b . fillCmd ); este . _strokeInstructions && este . _instructions . empuje ( b . strokeCmd )}; un . _getEllipseArc = función ( un , b , d , e ) { var f = d / 2 * 0,5522848 , h = e / 2 * 0,5522848 , i = un + d, j = b + E, D = un + d / 2 , e = b + e / 2 ; este . _activeInstructions . empuje ( nuevos  c ( este . _ctx . moveTo , [a, e]), nuevos  c ( este . _ctx . bezierCurveTo , [a, e - h, d - f, b, d, b]), nuevos  c ( este . _ctx . bezierCurveTo ,
[d + f, b, i, e - h, i, e]), nuevos  c ( este . _ctx . bezierCurveTo , [i, e + h, d + f, j, d, j]), nueva  c ( este . _ctx . bezierCurveTo , [d - f, j, a, e + h, a, e])); devolver  esta }; un . _newPath = función () { esto . _dirty && este . _updateInstructions (); este . _oldInstructions = presente . _instructions ; este . _activeInstructions = []; este . _active = presente . _dirty = false }; un . _setProp = función ( un , b ) { esto [a] = b}; g . Gráficos = b}) (CreateJS || (CreateJS = {})); ( función ( g ) { var  c = función () { esto . Inicializar ()}, b = c . Prototipo ; c . SuppressCrossDomainErrors = false ; c . _hitTestCanvas = g . createCanvas ? g . createCanvas () : documento . createElement ( " tela " ); c . _hitTestCanvas . anchura = c . _hitTestCanvas . altura = 1 ; c . _hitTestContext = c . _hitTestCanvas . getContext ( " 2d " ) ; c . _nextCacheID = 1 ; b . alpha = 1 ; b . cacheCanvas = nula ; b . Identificación = - 1 ; b . mouseEnabled = verdadero ; b . nombre = nula ; b . progenitor = nula ; b . regX = 0 ; b . REGY = 0 ; b . la rotación = 0 ; b . scaleX = 1 ; b . scaleY = 1 ; b . skewX = 0 ; b . skewY = 0 ; b . sombra = nula ; b . visible = verdadero ; b . x = 0 ; b . y = 0 ; b . compositeOperation =
nula ; b . snapToPixel = false ; b . onPress = nula ; b . onclick = nula ; b . OnDoubleClick = nula ; b . onMouseOver = nula ; b . onMouseOut = nula ; b . onTick = nula ; b . filtros = NULL ; b . CacheID = 0 ; b . enmascarar = nula ; b . hitArea = nula ; b . _cacheOffsetX = 0 ; b . _cacheOffsetY = 0 ; b . _cacheScale = 1 ; b . _cacheDataURLID = 0 ; b . _cacheDataURL = nula ; b . _matrix = nula ; b . inicializar = función () { esto . ID = g . UID . obtener (); este . _matrix = nueva  g.Matrix2D }; b . isVisible = función () { volver  este . visible && este . alpha > 0 && esto . scaleX ! = 0 && esto . scaleY =! 0 }; b . dibujar = función ( un , b ) { var c = presente . cacheCanvas ; si (b ||
! c) devolver  falsa ; var d = presente . _cacheScale ; un . drawImage (c, este . _cacheOffsetX , este . _cacheOffsetY , c . de anchura / d, c . de altura / d); volver  verdadera }; b . updateContext = función ( un ) { var b, c = presente . máscara , c && c . gráficos && (b = c . getMatrix ( c . _matrix ), una . transformar ( b . un , b . b , b . c , b . d , b . tx , b . ty ), c . gráficos . drawAsPath (una ), una . pinza (), b . invertir (), una . transformar ( b . un , b . b , b . c , b . d , b . tx , b . ty )); b = presente . _matrix . identidad (). appendTransform ( este . x , este . Y , este . scaleX , este . scaleY , este . rotación , este . skewX , este . skewY , este . regX , este . Regy ); g . Etapa . _snapToPixelEnabled &&
este . snapToPixel ? un . transformar ( b . un , b . b , b . c , b . d , b . tx + 0,5 | 0 , b . ty + 0,5 | 0 ) : una . transformar ( b . un , b . b , b . c , b . d , b . tx , b . ty ); un . globalAlpha * = presente . alfa ; si ( este . compositeOperation ) una . globalCompositeOperation = presente . compositeOperation ; este . sombra && esto . _applyShadow (a, este . sombra )}; b . caché = función ( un , b , c , d , e ) {e = e || 1 ; si ( ! este . cacheCanvas ) este . cacheCanvas = g . createCanvas ? g . createCanvas () : documento . createElement ( " tela " ); este . cacheCanvas . anchura = Math . ceil (c * e); este . cacheCanvas . Altura = Math . ceil (d * e); este . _cacheOffsetX = a; este . _cacheOffsetY =
segundo; este . _cacheScale = e || 1 ; este . updateCache ()}; b . updateCache = función ( un ) { var b = presente . cacheCanvas , m = presente . _cacheOffsetX , d = presente . _cacheOffsetY , e = esta . _cacheScale ; si ( ! b) tiro " caché () debe ser llamada antes de updateCache () " ; var f = b . getContext ( " 2d " ); f . guardar (); un || f . clearRect ( 0 , 0 , b . de ancho , b . de altura ); f . globalCompositeOperation = a; f . setTransform (e, 0 , 0 , e, - m, - d); este . dibujar (f, verdadera ); este . _applyFilters (); f . restaurar (); este . CacheID = c . _nextCacheID ++ }; b . uncache = función () { esto . _cacheDataURL = presente . cacheCanvas = nula ; este . CacheID = presente . _cacheOffsetX =
este . _cacheOffsetY = 0 ; este . _cacheScale = 1 }; b . getCacheDataURL = función () { si ( ! esto . cacheCanvas ) de retorno  nula ; si ( este . CacheID ! = esta . _cacheDataURLID ) este . _cacheDataURL = presente . cacheCanvas . toDataURL (); devolver  este . _cacheDataURL }; b . getStage = función () { a ( var un = presente ; una . matriz ;) un = un . los padres ; devolver un instanceof  g . Etapa ? una : nulo }; b . localToGlobal = función ( un , b ) { var c = presente . getConcatenatedMatrix ( este . _matrix ); si (c == nula ) de retorno  nula ; c . añadir ( 1 , 0 , 0 , 1 , a, b); volver  nueva  g.Point ( c . tx , c . ty )}; b . globalToLocal = función ( un , b ) { var c = presente . getConcatenatedMatrix ( este . _matrix );
si (c == nula ) de retorno  nula ; c . invertir (); c . añadir ( 1 , 0 , 0 , 1 , a, b); volver  nueva  g.Point ( c . tx , c . ty )}; b . localToLocal = función ( un , b , c ) {a = esta . localToGlobal (a, b); volver  c . globalToLocal ( un . x , un . y )}; b . setTransform = función ( un , b , c , d , e , f , h , i , j ) { esto . x = un || 0 ; este . Y = b || 0 ; este . scaleX = c == nula ? 1 : c; este . scaleY = d == nula ? 1 : d; este . la rotación = e || 0 ; este . skewX = f || 0 ; este . skewY = h || 0 ; este . regX = i || 0 ; este . REGY = j || 0 ; devolver  esta }; b . getMatrix = función ( un ) { retorno (a ? una . identidad () : nueva  g.Matrix2D ). appendTransform ( este . x , este . Y , este . scaleX , este . scaleY ,
este . rotación , este . skewX , este . skewY , este . regX , este . REGY ). appendProperties ( este . alpha , este . sombra , este . compositeOperation )}; b . getConcatenatedMatrix = función ( un ) {a ? un . identidad () : un = nueva  g.Matrix2D ; para ( var b = presente ; b ! = nula ;) una . prependTransform ( b . x , b . y , b . scaleX , b . scaleY , b . la rotación , b . skewX , b . skewY , b . regX , b . REGY ). prependProperties ( b . alfa , b . sombra , b . compositeOperation ), b = b . los padres ; volver a}; b . hitTest = función ( un , b ) { var m = c . _hitTestContext , d = c . _hitTestCanvas ; m . setTransform ( 1 , 0 , 0 , 1 , - a, - b); este . dibujar (m); m = presente . _testHit (m);
d . anchura = 0 ; d . anchura = 1 ; volver m}; b . clon = función () { var un = nueva  c ; este . cloneProps (a); volver a}; b . toString = función () { retorno " [DisplayObject (name = " + este . Nombre + " )] " }; b . cloneProps = función ( un ) { una . alfa = esta . alfa ; un . nombrar = esta . nombre ; un . regX = presente . regX ; un . REGY = presente . REGY ; un . rotación = esta . rotación ; un . scaleX = presente . scaleX ; un . scaleY = presente . scaleY ; un . sombra = presente . sombra ; un . skewX = presente . skewX ; un . skewY = presente . skewY ; un . visibles = presente . visible ; un . x = esta . x ; un . y = esta . y ; un . mouseEnabled = presente . mouseEnabled ; un . compositeOperation = presente . compositeOperation ;
si ( este . cacheCanvas ) una . cacheCanvas = presente . cacheCanvas . cloneNode ( verdadera ), una . cacheCanvas . getContext ( " 2d " ). putImageData ( este . cacheCanvas . getContext ( " 2D " ). getImageData ( 0 , 0 , este . cacheCanvas . anchura , este . cacheCanvas . altura ), 0 , 0 )}; b . _applyShadow = función ( un , b ) {b = b || Sombra . la identidad ; un . shadowColor = b . el color ; un . shadowOffsetX = b . offsetX ; un . shadowOffsetY = b . offsetY ; un . shadowBlur = b . desenfoque }; b . _tick = función ( un ) { si ( este . onTick ) si (a) de este . onTick . aplicar ( este , a); cosa  esta . onTick ()}; b . _testHit = función ( un ) { intente { var b = un . getImageData ( 0 , 0 , 1 ,
1 ). datos [ 3 ] > 1 } catch (m) { si ( ! c . suppressCrossDomainErrors ) tiro " . Se ha producido un error Esto es muy probablemente debido a restricciones de seguridad en la lectura de los datos de píxeles de la lona con imágenes locales o entre dominios. " ;} volver b}; b . _applyFilters = función () { si ( este . filtros && esto . filtros . de longitud ! = 0 && esto . cacheCanvas ) de ( var un = presente . filtros . de longitud , b = presente . cacheCanvas . getContext ( " 2d " ), c = presente . cacheCanvas . de ancho , d = presente . cacheCanvas . de altura , e = 0 ; e < a; e ++ ) este . filtros [e]. applyFilter (b, 0 , 0 , c, d)}; g . DisplayObject = c}) (CreateJS || (CreateJS =
{})); ( Función ( g ) { var  c = función () { esto . Inicializar ()}, b = c . Prototipo = nueva  g.DisplayObject ; b . Los niños = NULL ; b . DisplayObject_initialize = b . Inicializar ; b . inicializar = función () { esto . DisplayObject_initialize (); esto . hijos = []}; b . isVisible = función () { volver  este . visibles && esto . alpha > 0 && esto . hijos . longitud && esto . scaleX ! = 0 && esto . scaleY =! 0 }; b . DisplayObject_draw = b . dibujar ; b . dibujar = función ( un , b ) { si ( este . DisplayObject_draw (a, b)) volver  verdadera ; de ( var c = este . hijos . rebanada ( 0 ), d = 0 , e = c . de longitud ; d < e, d ++ ) { var f = c [d]; f . isVisible () &&
( Un . Guardar (), f . UpdateContext (a), f . Dibujar (a), una . Restaurar ())} regresar  verdadera }; b . addChild = función ( un ) { si (a == nula ) volver a; var b = argumentos . longitud ; si (b > 1 ) { a ( var c = 0 ; c < b, c ++ ) este . AddChild ( argumentos [c]); volver  argumentos [b - 1 ]} a . padre && una . padre . removeChild (a); un . matriz = presente ; este . los niños . empujar (a); volver a}; b . addChildAt = función ( un , b ) { var c = argumentos . de longitud , d = argumentos [c - 1 ]; si (d < 0 || d > presente . niños . de longitud ) volver  argumentos [C - 2 ]; si (c > 2 ) { a ( var e = 0 ; e < c - 1 ; e ++ ) este . addChildAt ( argumentos [E], d + e); volver  argumentos [c - 2 }] una . padre &&
un . padre . removeChild (a); un . matriz = presente ; este . los niños . de empalme (b, 0 , a); volver a}; b . removeChild = función ( un ) { var b = argumentos . longitud ; si (b > 1 ) { a ( var c = cierto , d = 0 ; d < b, d ++ ) c = c && esto . removeChild ( argumentos [d]); retorno c} regreso  este . removeChildAt ( este . niños . indexOf } (a)); b . removeChildAt = función ( un ) { var b = argumentos . longitud ; si (b > 1 ) { a ( var c = [], d = 0 ; d < b, d ++ ) c [d] = argumentos [d]; c . tipo ( función ( un , b ) { retorno b - a}); para ( var e = cierto , d = 0 ; d < b, d ++ ) e = e && esto . removeChildAt (c [d]); retorno e} si (a < 0 || una > presente . hijos . Longitud - 1 ) volver  falsa ;
si (b = esta . hijos [a]) b . matriz = nula ; este . los niños . empalmar (a, 1 ); volver  verdadera }; b . removeAllChildren = función () { a ( var a = esta . hijos ; una . de longitud ;) una . pop (). matriz = nulo }; b . getChildAt = función ( un ) { volver  este . hijos [a]}; b . sortChildren = función ( un ) { esto . los niños . tipo (a)}; b . getChildIndex = función ( un ) { volver  este . los niños . indexOf (a)}; b . getNumChildren = función () { volver  este . los niños . longitud }; b . swapChildrenAt = función ( un , b ) { var c = presente . niños , d = c [A], e = c [b]; d && e && (c [a] = e, c [b] = d)}; b . swapChildren = función ( un , b ) { a ( var c =
este . niños , d, e, f = 0 , h = c . longitud ; f < h; f ++ ) si (c [f] == una && (d = f), c [f] == b && (e = f), d ! = nula && e ! = nula ) romper ; f ! = h && (c [d] = b, c [e] = a)}; b . setChildIndex = función ( un , b ) { var c = presente . niños , d = c . longitud ; si ( ! ( una . matriz ! = esta || b < 0 || b > = d)) { a ( var e = 0 ; e < d; e ++ ) si (c [e] == a) ruptura ; e == d || e == b || ( C . Empalmar (e, 1 ), b < e && b - , c . Empalmar (b, 0 , a))}}; b . contiene = función ( un ) { a (; a;) { si (a == este ) volver  verdadera ; un = un . matriz } regresar  falsa }; b . hitTest = función ( un , b ) { volver  este . getObjectUnderPoint (a, b) =! nulo }; b . getObjectsUnderPoint = función ( un , b ) { var c = [], d =
este . localToGlobal (a, b); este . _getObjectsUnderPoint ( d . x , d . y , c); volver c}; b . getObjectUnderPoint = función ( un , b ) { var c = presente . localToGlobal (a, b); devolver  este . _getObjectsUnderPoint ( c . x , c . y )}; b . clon = función ( un ) { var b = nueva  c ; este . cloneProps (B); si (a) de ( var m = b . los niños = [], d = 0 , e = presente . niños . de longitud ; d < e, d ++ ) { var f = presente . los niños [d]. clon (a); f . matriz = b; m . empuje (f)} retorno b}; b . toString = función () { retorno " [Container (name = " + este . Nombre + " )] " }; b . DisplayObject__tick = b . _tick ; b . _tick = función ( un ) { a ( var b = presente . hijos . Longitud -
1 ; b > = 0 ; b - ) { var c = presente . hijos [b]; c . _tick && c . _tick (a)} esta . DisplayObject__tick (a)}; b . _getObjectsUnderPoint = función ( un , b , m , d ) { var e = CreateJS . DisplayObject . _hitTestContext , f = CreateJS . DisplayObject . _hitTestCanvas , h = presente . _matrix , i = d y 1 && ( este . onPress || esto . onClick || esto . OnDoubleClick ) || d y 2 && ( este . onMouseOver || este . onMouseOut ); si ( este . cacheCanvas && i && ( este . getConcatenatedMatrix (h), e . setTransform ( h . a , h . b , h . c , h . d , h . tx - a, h . Ty - b), e . globalAlpha = h . alfa , este . dibujar (e), este . _testHit (e))) de retorno  f . anchura = 0 , f . anchura =
1 , este ; para ( var j = presente . hijos . Longitud - 1 ; j > = 0 ; j - ) { var g = presente . los niños [j]; si ( g . isVisible () && g . mouseEnabled ) si (g instanceof c) si (i) { si (g = g . _getObjectsUnderPoint (a, b)) devolver  esta } demás { si (g = g . _getObjectsUnderPoint (una , b, m, d), ! m && g) de retorno g} demás  si ( ! d || i || d y 1 && ( g . onPress || g . onClick || g . OnDoubleClick ) || d y 2 && ( g . onMouseOver || g . onMouseOut )) { var n = g . hitArea ; g . getConcatenatedMatrix (h); n && ( h . appendTransform ( n . x + g . regX , n . y + g . Regy , n . scaleX , n . scaleY , n . rotación , n . skewX , n . skewY , n . regX , n . REGY ), h . alpha * = n . alpha / g . alpha );
e . globalAlpha = h . alfa ; e . setTransform ( h . a , h . b , h . c , h . d , h . tx - a, h . Ty - b); (n || g). dibujar (e); si ( este . _testHit (e)) si ( f . de ancho = 0 , f . de anchura = 1 , i) volver  este ; otra cosa  si (m) m . empuje (g); otra  vuelta g}} retorno  nulo }; g . Container = c}) (CreateJS || (CreateJS = {})); ( función ( g ) { var  c = función ( un ) { esto . Inicializar (a)}, b = c . Prototipo = nueva  g.Container ; c . _snapToPixelEnabled = false ; b . AUTOCLEAR = verdadero ; b . lienzo = nula ; b . mouseX = 0 ; b . mouseY = 0 ; b . onMouseMove = nula ; b . onMouseUp = nula ; b . onMouseDown = nula ; b . snapToPixelEnabled = false ; b . mouseInBounds = false ; b . tickOnUpdate = verdadero ; b . mouseMoveOutside = false ; b . _pointerData = nula ; b . _pointerCount = 0 ; b . _primaryPointerID = nula ; b . _mouseOverIntervalID = nula ; b . Container_initialize = b . inicializar ; b . inicializar = función ( un ) { esto . Container_initialize (); esto . lienzo =
un instanceof  HTMLCanvasElement ? una : documento . getElementById (a); este . _pointerData = {}; este . _enableMouseEvents ( verdaderos )}; b . actualización = función () { si ( este . lona ) { esto . AUTOCLEAR && esto . claro (); c . _snapToPixelEnabled = presente . snapToPixelEnabled ; este . tickOnUpdate && este . _tick ( argumentos . de longitud ? argumentos : nulos ); var un = presente . lienzo . getContext ( " 2d " ); un . guardar (); este . updateContext (a); este . dibujar (a, falsa ); un . restaurar ()}}; b . tick = b . actualizar ; b . claro = función () { si ( este . lona ) { var un = presente . lienzo . getContext ( " 2d " ); un . setTransform ( 1 , 0 , 0 , 1 , 0 , 0 ); un . clearRect ( 0 ,
0 , este . lienzo . anchura , este . lienzo . altura )}}; b . toDataURL = función ( un , b ) {b || (b = " image / png " ); var c = esta . lienzo . getContext ( " 2d " ), d = presente . lienzo . anchura , e = esta . lienzo . altura , f; si (a) {f = c . getImageData ( 0 , 0 , d, e); var h = c . globalCompositeOperation ; c . globalCompositeOperation = " destino-over " ; c . fillStyle = a; c . fillRect ( 0 , 0 , d, e)} var g = esta . lienzo . toDataURL (b); si (a) c . clearRect ( 0 , 0 , d, e), c . putImageData (f, 0 , 0 ), c . globalCompositeOperation = h; volver g}; b . enableMouseOver = función ( un ) { si ( este . _mouseOverIntervalID ) clearInterval ( este . _mouseOverIntervalID ),
este . _mouseOverIntervalID = nula ; si (a == nula ) un = 20 ; otra cosa  si (a <= 0 ) de retorno ; var b = presente ; este . _mouseOverIntervalID = setInterval ( función () { b . _testMouseOver ()}, 1E3 / Matemáticas . min ( 50 , a))}; b . clon = función () { var un = nueva  c ( nulo ); este . cloneProps (a); volver a}; b . toString = función () { retorno " [el escenario (nombre = " + este . Nombre + " )] " }; b . _enableMouseEvents = función () { var un = este , b = ventana . addEventListener ? Ventana : documento ; b . addEventListener ( " mouseUp " , la función ( b ) { una . _handleMouseUp (b)}, false ); b . addEventListener ( " mouseMove " , la función ( b ) { una . _handleMouseMove (b)},
false ); b . addEventListener ( " dblclick " , la función ( b ) { una . _handleDoubleClick (b)}, false ); este . lienzo && este . lienzo . addEventListener ( " mousedown " , la función ( b ) { una . _handleMouseDown (b)}, false )}; b . _getPointerData = función ( un ) { var b = presente . _pointerData [a]; si ( ! b && (b = presente . _pointerData [a] = {x : 0 , Y : 0 }, este . _primaryPointerID == nula )) este . _primaryPointerID = a; volver b}; b . _handleMouseMove = función ( un ) { si ( ! ) un = ventana . evento ; este . _handlePointerMove ( - 1 , a, a . pageX , un . pageY )}; b . _handlePointerMove = función ( un , b , c , d ) { si ( este . lona ) { var e =
este . _getPointerData (a), f = e . dentro del campo ; este . _updatePointerPosition (a, c, d); si (f || e . Inbounds || este . mouseMoveOutside ) {a = nuevo  g.MouseEvent ( " onMouseMove " , e . x , e . y , esto , b, a, a == este . _primaryPointerID , e . rawX , e . rawy ); si ( este . onMouseMove ) este . onMouseMove (a); si ( e . evento && e . evento . onMouseMove ) un = un . clon (), un . target = e . evento . objetivo , e . evento . onMouseMove (a)}}}; b . _updatePointerPosition = función ( un , b , c ) { var d = esta . lona ; hacer b - = d . offsetLeft , c - = d . offsetTop ; mientras que (d = d . offsetParent ); var d = presente . lienzo . anchura , e = esta . lienzo . altura , f =
este . _getPointerData (a); si ( f . Inbounds = b > = 0 && c > = 0 && b <= d - 1 && c <= e - 1 ) f . x = b, f . Y = C; otra cosa  si ( este . mouseMoveOutside ) f . x = b < 0 ? 0 : b > d - 1 ? d - 1 : b, f . Y = C < 0 ? 0 : c > e - 1 ? E - 1 : c; f . rawX = b; f . rawy = C; si (a == este . _primaryPointerID ) este . mouseX = f . x , este . mouseY = f . y , este . mouseInBounds = f . Inbounds }; b . _handleMouseUp = función ( un ) { esto . _handlePointerUp ( - 1 , un, falsa )}; b . _handlePointerUp = función ( un , b , c ) { var d = esta . _getPointerData (a), e = nuevo  g.MouseEvent ( " onMouseUp " , d . x , d . y , esto , b, a, a == este . _primaryPointerID , d . rawX , d . rawy ); si ( este . onMouseUp ) este . onMouseUp (e);
si ( d . evento && d . evento . onMouseUp ) e = e . clon (), e . target = d . evento . objetivo , d . evento . onMouseUp (e); si ( d . objetivo && d . de destino . onClick && esto . _getObjectsUnderPoint ( d . x , d . Y , nula , cierto , este . _mouseOverIntervalID ? 3 : 1 ) == d . de destino ) d . diana . onClick ( nueva  g.MouseEvent ( " onClick " , d . x , d . y , d . de destino , b, a, a == esto . _primaryPointerID , d . rawX , d . rawy )); si (c) { si (a == esto . _primaryPointerID ) este . _primaryPointerID = nula ; Eliminar  esta . _pointerData [a]} demás  d . evento = d . target = nulo }; b . _handleMouseDown = función ( un ) { esto . _handlePointerDown ( - 1 , un, falsa )}; b . _handlePointerDown =
función ( un , b , c , d ) { var e = esta . _getPointerData (a), d ! = nula && esto . _updatePointerPosition (a, c, d); si ( este . onMouseDown ) este . onMouseDown ( nuevo  g.MouseEvent ( " onMouseDown " , e . x , e . y , esto , b, a, a == este . _primaryPointerID , e . rawX , e . rawy )); si (c = esta . _getObjectsUnderPoint ( e . x , e . y , nulo , esta . _mouseOverIntervalID ? 3 : 1 )) { si ( c . onPress && (a = nuevo  g.MouseEvent ( " onPress " , e . x , e . Y , c, b, a, a == este . _primaryPointerID , e . rawX , e . rawy ), c . onPress (a), un . onMouseMove || una . onMouseUp )) e . evento = a; e . target = c}}; b . _testMouseOver = función () { si ( este . _primaryPointerID ==
- 1 &&! ( Este . MouseX == esto . _mouseOverX && Esto . MouseY == esto . _mouseOverY && Esto . MouseInBounds )) { var un = nula ; si ( este . mouseInBounds ) un = presente . _getObjectsUnderPoint ( este . mouseX , este . mouseY , nula , 3 ), este . _mouseOverX = presente . mouseX , este . _mouseOverY = presente . mouseY ; si ( este . _mouseOverTarget ! = a) { si ( este . _mouseOverTarget && esto . _mouseOverTarget . onMouseOut ) este . _mouseOverTarget . onMouseOut ( nueva  g.MouseEvent ( " onMouseOut " , este . mouseX , este . mouseY , este . _mouseOverTarget )); si (a && una . onMouseOver ) una . onMouseOver ( nueva  g.MouseEvent ( " onMouseOver " ,
este . mouseX , este . mouseY , a)); este . _mouseOverTarget = a}}}; b . _handleDoubleClick = función ( un ) { si ( este . OnDoubleClick ) este . OnDoubleClick ( nueva  g.MouseEvent ( " OnDoubleClick " , este . mouseX , este . mouseY , esta , una, - 1 , verdadera )); var b = presente . _getObjectsUnderPoint ( este . mouseX , este . mouseY , nulo , esta . _mouseOverIntervalID ? 3 : 1 ); si (b && b . OnDoubleClick ) b . OnDoubleClick ( nueva  g.MouseEvent ( " OnDoubleClick " , este . mouseX , este . mouseY , B, A, - 1 , verdadera ))}; g . Etapa = c}) (CreateJS || (CreateJS = {})); ( función ( g ) { var  c = función ( un ) { esto . Inicializar (a)}, b = c . Prototipo = nueva  g.DisplayObject ; b . la imagen = nula ; b . snapToPixel = verdadero ; b . sourceRect = nula ; b . DisplayObject_initialize = b . inicializar ; b . inicializar = función ( un ) { esto . DisplayObject_initialize (); typeof un == " cadena " ? ( este . imagen = nueva  imagen , esta . imagen . src = a) : este . imagen = a}; b . isVisible = función () { volver  este . visibles && esto . alpha > 0 && esto . scaleX =! 0 && este . scaleY ! = 0 && esto . imagen && ( este . imagen . completar || esto . imagen . getContext || esto . imagen . readyState > = 2 )}; b . DisplayObject_draw = b . dibujar ;
b . dibujar = función ( un , b ) { si ( este . DisplayObject_draw (a, b)) volver  verdadera ; var c = esta . sourceRect ; c ? un . drawImage ( este . imagen , c . x , c . Y , c . de ancho , c . de altura , 0 , 0 , c . de ancho , c . de altura ) : una . drawImage ( este . imagen , 0 , 0 ); volver  verdadera }; b . clon = función () { var un = nueva  c ( este . imagen ); este . cloneProps (a); volver a}; b . toString = función () { retorno " [Bitmap (name = " + este . Nombre + " )] " }; g . Mapa de bits = c}) (CreateJS || (CreateJS = {})); ( función ( g ) { var  c = función ( un ) { esto . Inicializar (a)}, b = c . Prototipo = nueva  g.DisplayObject ; b . onAnimationEnd = nula ; b . currentFrame = - 1 ; b . currentAnimation = nula ; b . pausa = verdadero ; b . spritesheet = nula ; b . snapToPixel = verdadero ; b . compensado = 0 ; b . currentAnimationFrame = 0 ; b . _advanceCount = 0 ; b . _animation = nula ; b . DisplayObject_initialize = b . inicializar ; b . inicializar = función ( un ) { esto . DisplayObject_initialize (); esto . spritesheet = a}; b . isVisible = función () { retorno  este . visibles && esto . alpha > 0 && esto . scaleX ! = 0 && esto . scaleY ! = 0 && esto . spritesheet . completa &&
este . currentFrame > = 0 }; b . DisplayObject_draw = b . dibujar ; b . dibujar = función ( un , b ) { si ( este . DisplayObject_draw (a, b)) volver  verdadera ; este . _normalizeFrame (); var c = esta . spritesheet . GetFrame ( este . currentFrame ); si (c ! = nula ) { var d = c . rect ; un . drawImage ( c . la imagen , d . x , d . y , d . de ancho , d . de altura , - c . regX , - c . REGY , d . de ancho , d . de altura ); volver  verdadera }}; b . jugar = función () { esto . pausa = false }; b . parada = función () { esto . pausa = verdadero }; b . gotoAndPlay = función ( un ) { esto . pausa = false ; este . _goto (a)}; b . gotoAndStop = función ( un ) { esto . pausa = verdadero ; este . _goto (a)}; b . adelantado =
la función () { esto . _animation ? este . currentAnimationFrame ++ : este . currentFrame ++ ; este . _normalizeFrame ()}; b . clon = función () { var a = nuevos  c ( este . spritesheet ); este . cloneProps (a); volver a}; b . toString = función () { retorno " [BitmapAnimation (name = " + este . Nombre + " )] " }; b . DisplayObject__tick = b . _tick ; b . _tick = función ( un ) { var b = presente . _animation ? este . _animation . Frecuencia : 1 ; ! este . pausa && ( ++ esto . _advanceCount + esto . compensado ) % b == 0 && esto . avanzar (); este . DisplayObject__tick (a)}; b . _normalizeFrame = función () { var un = presente . _animation ; si (a) si ( este . currentAnimationFrame > =
un . marcos . longitud ) { si ( un . próxima ? esto . _goto ( un . siguiente ) : ( este . pausa = cierto , este . currentAnimationFrame = una . marcos . de longitud - 1 , este . currentFrame = una . marcos [ esto . currentAnimationFrame ]) , este . onAnimationEnd ) este . onAnimationEnd ( este , un . nombre )} lo demás  esta . currentFrame = una . marcos [ esto . currentAnimationFrame ]; otra cosa  si ( este . currentFrame > = presente . spritesheet . getNumFrames () && ( este . currentFrame = 0 , este . onAnimationEnd )) este . onAnimationEnd ( este , nula )}; b . DisplayObject_cloneProps = b . cloneProps ; b . cloneProps = función ( un ) { esto . DisplayObject_cloneProps (a);
un . onAnimationEnd = presente . onAnimationEnd ; un . currentFrame = presente . currentFrame ; un . currentAnimation = presente . currentAnimation ; un . pausa = presente . en pausa ; un . compensado = presente . desplazamiento ; un . _animation = presente . _animation ; un . currentAnimationFrame = presente . currentAnimationFrame }; b . _goto = función ( un ) { si ( isNaN (a)) { var b = presente . spritesheet . getAnimation (a); si (b) de este . currentAnimationFrame = 0 , este . _animation = b, presente . currentAnimation = a, este . _normalizeFrame ()} lo demás  esta . currentAnimation = presente . _animation = nula , este . currentFrame = a}; g . BitmapAnimation = c}) (CreateJS ||
(CreateJS = {})); ( función ( g ) { var  c = función ( un ) { esto . inicializar (a)}, b = c . prototipo = nueva  g.DisplayObject ; b . gráficos = nula ; b . DisplayObject_initialize = b . inicializar ; b . inicializar = función ( un ) { esto . DisplayObject_initialize (); esto . gráficos = un ? un : nuevos  g.Graphics }; b . isVisible = función () { volver  booleana ( este . visibles && este . alpha > 0 && esto . scaleX ! = 0 && esto . scaleY =! 0 && esto . gráficos )}; b . DisplayObject_draw = b . dibujar ; b . dibujar = función ( un , b ) { si ( este . DisplayObject_draw ( a, b)) volver  verdadera ; esto . gráficos . dibujar (a); devolver  cierto }; b . clon = función ( a ) {a = nuevos  c (a &&
este . los gráficos ? este . gráficos . clone () : este . gráficos ); este . cloneProps (a); volver a}; b . toString = función () { retorno " [Forma (name = " + este . Nombre + " )] " }; g . Forma = c}) (CreateJS || (CreateJS = {})); ( función ( g ) { var  c = función ( un , b , c ) { esto . Initialize (a, b, c)}, b = c . prototipo = nueva  g.DisplayObject ; c . _workingContext = ( g . createCanvas ? g . createCanvas () : documento . createElement ( " tela " )). getContext ( " 2d " ); b . texto = " " ; b . la fuente = nula ; b . el color = " # 000 " ; b . textAlign = " izquierda " ; b . TextBaseline = " superior " ; b . anchoMax = nula ; b . delinear = false ; b . lineHeight = 0 ; b . anchoLinea = nula ; b . DisplayObject_initialize = b . inicializar ; b . inicializar = función ( un , b , c ) { esto . DisplayObject_initialize (); esta . texto = a; esto . fuente = b; esta . de color = c ? c : " # 000 " }; b . isVisible = función () { volver  booleana ( este . visibles &&
este . alpha > 0 && esto . scaleX ! = 0 && esto . scaleY ! = 0 && esto . texto ! = nula && esto . texto ==! " " )}; b . DisplayObject_draw = b . dibujar ; b . dibujar = función ( un , b ) { si ( este . DisplayObject_draw (a, b)) volver  verdadera ; este . esbozar ? un . strokeStyle = presente . de color : una . fillStyle = presente . el color ; un . fuente = presente . fuente ; un . textAlign = presente . textAlign || " Comenzar " ; un . TextBaseline = presente . TextBaseline || " Alfabética " ; este . _drawText (a); volver  verdadera }; b . getMeasuredWidth = función () { volver  este . _getWorkingContext (). measureText ( este . texto ). anchura }; b . getMeasuredLineHeight = función () { volver  este . _getWorkingContext (). measureText ( " M " ). ancho *
1.2 }; b . getMeasuredHeight = función () { volver  este . _drawText () * ( este . lineHeight || este . getMeasuredLineHeight ())}; b . clon = función () { var un = nuevos  c ( este . texto , este . letra , esta . de color ); este . cloneProps (a); volver a}; b . toString = función () { retorno " [texto (text = " + ( este . texto . de longitud > 20 ? esto . texto . substr ( 0 , 17 ) + " ... " : este . texto ) + " )] " }; b . DisplayObject_cloneProps = b . cloneProps ; b . cloneProps = función ( un ) { esto . DisplayObject_cloneProps (a); un . textAlign = presente . textAlign ; un . TextBaseline = presente . TextBaseline ; un . anchoMax = presente . anchoMax ; un . esbozo =
este . esbozar ; un . lineHeight = presente . lineHeight ; un . anchoLinea = presente . anchoLinea }; b . _getWorkingContext = función () { var un = c . _workingContext ; un . fuente = presente . fuente ; un . textAlign = presente . textAlign || " Comenzar " ; un . TextBaseline = presente . TextBaseline || " Alfabética " ; volver a}; b . _drawText = función ( un ) { var b = !! a; b || (a = esta . _getWorkingContext ()); para ( var c = Cadena ( este . texto .) de división ( / (?: \ r \ n | \ r | \ n ) / ), d = presente . lineHeight || esto . getMeasuredLineHeight (), e = 0 , f = 0 , h = c . de longitud ; f < h; f ++ ) { var g = una . measureText (c [f]). ancho ; si ( este . anchoLinea == nula || g < esto . anchoLinea ) b &&
este . _drawTextLine (a, c [f], e * d); otra cosa { a ( var g = . c [f] de división ( / ( \ s ) / ), j = g [ 0 ], l = 1 , n = g . de longitud ; l < n; l + = 2 ) una . measureText (j + g [l] + g [l + 1 ]). anchura > presente . LineWidth ? (b && este . _drawTextLine (a, j, e * d), e ++ , j = g [l + 1 ]) : j + = g [l] + g [l + 1 ]; b && este . _drawTextLine (a, j, e * d)} e ++ } retorno e}; b . _drawTextLine = función ( un , b , c ) { esto . esbozar ? un . strokeText (b, 0 , c, este . anchoMax || 65535 ) : una . fillText (b, 0 , c, este . anchoMax || 65535 )}; g . Texto = c}) (CreateJS || (CreateJS = {})); ( función ( g ) { var  c = función () { tiran " SpriteSheetUtils no se pueden crear instancias " ;}; c . _workingCanvas = G . CreateCanvas ? G . createCanvas () : documento . createElement ( " tela " ); c . _workingContext = c . _workingCanvas . getContext ( " 2d " ); c . addFlippedFrames = función ( b , una , k , g ) { si (a || k | | g) { var d = 0 ; una && c . _flip (b, ++ d, verdadero , falso ); k && c . _flip (b, ++ d, falso , verdadero ); g && c . _flip (b , ++ d, cierto , cierto )}}; c . extractFrame = función ( b , un ) { isNaN (a) && (a = b . getAnimation (a). marcos [ 0 ]); var k = b . GetFrame (a); si ( ! k) de retorno  nulo ; var g = k . rect , d = c . _workingCanvas ; d . de anchura =
g . ancho ; d . Altura = g . altura ; c . _workingContext . drawImage ( k . imagen , g . x , g . y , g . de anchura , g . de altura , 0 , 0 , g . de anchura , g . de altura ); k = nueva  imagen ; k . src = d . toDataURL ( " image / png " ); volver k}; c . mergeAlpha = función ( b , una , c ) {c || (c = g . createCanvas ? g . createCanvas () : documento . createElement ( " tela " )); c . anchura = Math . max ( una . anchura , b . ancho ); c . Altura = Math . max ( una . altura , b . de altura ); var m = c . getContext ( " 2d " ); m . guardar (); m . drawImage (b, 0 , 0 ); m . globalCompositeOperation = " destino-in " ; m . drawImage (a, 0 , 0 ); m . restaurar (); volver c}; c . _flip = función ( b , una , k , g ) { a ( var d =
b . _images , e = c . _workingCanvas , f = c . _workingContext , h = d . Longitud / a, i = 0 ; i < h; i ++ ) { var j = d [i]; j . __tmp = i; e . anchura = 0 ; e . anchura = j . ancho ; e . Altura = j . altura ; f . setTransform (k ? - 1 : 1 , 0 , 0 , g ? - 1 : 1 , k ? j . anchura : 0 , g ? j . Altura : 0 ); f . drawImage (j, 0 , 0 ); var l = nueva  imagen ; l . src = e . toDataURL ( " image / png " ); l . anchura = j . ancho ; l . Altura = j . altura ; d . empuje (l)} f = b . _frames ; e = f . longitud / a; para (i = 0 ; i < e; i ++ ) { var j = f [i], n = j . rect . clone (), l = d [ j . imagen . __tmp + h * a], p = {imagen : l, rect : n, regX : j . regX , REGY : j . REGY }; si (k) n . x = l . ancho - n . x - n . anchura , p . regX = n . ancho - j . regX ; si (g) n . Y =
l . altura - n . y - n . altura , p . REGY = n . Altura - j . REGY ; f . empuje (p)} k = " _ " + (k ? " h " : " " ) + (g ? " v " : " " ); g = b . _animations ; b = b . _data ; d = g . longitud / a; para (i = 0 ; i < d; i ++ ) {f = g [i]; j = b [f]; h = {nombre : f + k, frecuencia : j . frecuencia , al lado : j . siguiente , monturas : []}; j . junto && ( h . próximo + = k); f = j . marcos ; j = 0 ; de (l = f . de longitud ; j < l; j ++ ) h . marcos . empuje (f [j] + e * a), b [ h . nombrar ] = h; g . pulsador ( h . nombre )}}; g . SpriteSheetUtils = c}) (CreateJS || (CreateJS = {})); ( función ( g ) { var  c = función () { esto . Inicializar ()}, b = c . Prototipo ; c . ERR_DIMENSIONS = " dimensiones del marco exceda las dimensiones spritesheet max " ; c . ERR_RUNNING = " una construcción ya está en ejecución " ; b . anchoMax = 2,048 ; b . maxHeight = 2,048 ; b . spritesheet = nula ; b . escala = 1 ; b . almohadillado = 1 ; b . _frames = nula ; b . _animations = nula ; b . _data = nula ; b . _nextFrameIndex = 0 ; b . _index = 0 ; b . _callback = nula ; b . _timeSlice = nula ; b . _timerID = nula ; b . _scale = 1 ; b . inicializar = función () { esto . _frames = []; esto . _animations = {}}; b . ADDFRAME = función ( un , b , g , d , e , f ) { si ( este . _data ) tirar  c . ERR_RUNNING ;
b = b || un . límites || un . nominalBounds ; ! b && una . getBounds && (b = un . getBounds ()); si ( ! b) de retorno  nulo ; g = g || 1 ; devolver  este . _frames . empuje ({fuente : una, sourceRect : b, escala : g, esta func : d, params : correo, alcance : f, índice : este . _frames . de longitud , altura : b . altura * g}) - 1 }; b . addAnimation = función ( un , b , g , d ) { si ( este . _data ) tiro  c . ERR_RUNNING ; este . _animations [a] = {marcos : b, próxima : g, frecuencia : d}}; b . addMovieClip = función ( un , b , g ) { si ( este . _data ) tiro  c . ERR_RUNNING ; var d = una . frameBounds , e = b || un . límites || un . nominalBounds ; ! e && una . getBounds && (e = una . getBounds ()); si ( ! e &&! d) retorno  nula ;
para ( var b = un . línea de tiempo . duración , f = 0 ; f < b; f ++ ) este . ADDFRAME (a, d && d [f] ? d [f] : E, G, la función ( un ) { var b = presente . ACTIONSENABLED ; esto . ACTIONSENABLED = false ; esto . gotoAndStop (a); esto . ACTIONSENABLED = b },[fa); var f = una . línea de tiempo . _labels , un = [], h; para (h en f) una . empuje ({index : f [h], la etiqueta : h}); si ( a . de longitud ) { a . tipo ( función ( un , b ) { volver  una . Índice - b . Índice }); f = 0 ; para (h = un . de longitud ; f < h; f ++ ) { a ( var g = a [f]. etiqueta , d = f == h - 1 ? b : una [f + 1 ]. índice , e = [], i = a [f]. índice ; i < d; i ++ ) e . empuje (i); este . addAnimation (g, e, verdadera )}}}; b . construir = función () { si ( este . _data ) tiro  c . ERR_RUNNING ;
este . _callback = nula ; para ( este . _startBuild (); esto . _drawNext ();); este . _endBuild (); devolver  este . spritesheet }; b . buildAsync = función ( un , b ) { si ( este . _data ) tiro  c . ERR_RUNNING ; este . _callback = a; este . _startBuild (); este . _timeSlice = Math . max ( 0,01 , Math . min ( 0,99 , b || 0.3 )) * 50 ; var g = presente ; este . _timerID = setTimeout ( función () { g . _run ()}, 50 - este . _timeSlice )}; b . stopAsync = función () { clearTimeout ( este . _timerID ); este . _data = nulo }; b . clon = función () { lanzar " SpriteSheetBuilder no puede ser clonado. " ;}; b . toString = función () { retorno " [SpriteSheetBuilder] " };
b . _startBuild = función () { var un = presente . acolchado || 0 ; este . spritesheet = nula ; este . _index = 0 ; este . _scale = presente . escala ; var b = []; este . _data = {imágenes : [], marcos : b, animaciones : este . _animations }; var m = esta . _frames . rebanada (); m . tipo ( función ( un , b ) { volver  una . altura <= b . altura ? - 1 : 1 }); si ([m m . de longitud - 1 ]. altura + un * 2 > presente . maxHeight ) tiro  c . ERR_DIMENSIONS ; para ( var d = 0 , e = 0 , f = 0 ; m . de longitud ;) { var h = presente . _fillRow (m, d, f, b, a); si ( h . w > e) e = h . w ; d + = h . h ; si ( ! h . h ||! m . de longitud ) { var i = g . createCanvas ? g . createCanvas () : documento . createElement ( " tela " ); i . anchura =
este . _getSize (e, este . anchoMax ); i . Altura = presente . _getSize (d, este . maxHeight ); este . _data . imágenes [f] = i; h . h || (e = d = 0 , f ++ )}}}; b . _getSize = función ( un , b ) { a ( var c = 4 ; matemáticas . pow ( 2 , ++ c) < a;); volver  matemáticas . min (b, Math . pow ( 2 , c))}; b . _fillRow = función ( un , b , m , d , e ) { var f = presente . anchoMax , h = presente . maxHeight - b, i = e; b + = e; para ( var j = 0 , l = una . longitud - 1 ; l > = 0 ; l - ) { var n = a [l], p = presente . _scale * n . escala , O = n . sourceRect , r = n . fuente , q = Math . baja (p * O . x - e), t = Math . baja (p * O . y - e), s = Math . ceil (p * O . altura + e * 2 ), O = Math . ceil (p * O . anchura + e * 2 ); si (o > f) tiro  c . ERR_DIMENSIONS ;
si ( ! (s > h || i + S > f)) n . img = m, n . rect = nueva  g.Rectangle (i, B, O, s), j = j || s, un . empalmar (l, 1 ), d [ n . Índice ] = [i, B, O, s, m, Math . redonda ( - q + p * r . regX - e), Math . redonda ( - t + p * r . REGY - e)], i + = o} retorno {w : i, h : j}}; b . _endBuild = función () { esto . spritesheet = nueva  g.SpriteSheet ( este . _data ); este . _data = nula ; este . _callback && este . _callback ( este )}; b . _run = función () { a ( var un = ( nueva  fecha ). getTime () + este . _timeSlice , b = false ; una > ( nueva  fecha .) getTime ();) si ( ! esto . _drawNext ()) { b = verdadero ; descanso } si (b) de este . _endBuild (); otra cosa { var c = presente ; este . _timerID = setTimeout ( función () { c . _run ()},
50 - este . _timeSlice )}}; b . _drawNext = función () { var un = presente . _frames [ esto . _index ], b = un . escala * esto . _scale , c = una . rect , d = una . sourceRect , e = presente . _data . imágenes [ a . img ]. getContext ( " 2d " ); un . Esta func && una . Esta func . aplicar ( un . alcance , un . params ); e . guardar (); e . beginPath (); e . rect ( c . x , c . Y , c . de ancho , c . de altura ); e . Clip (); e . traducir ( Math . ceil ( c . x - d . x * b), Math . ceil ( c . y - d . y * b)); e . escala (a, b); un . fuente . dibujar (e); e . restaurar (); volver ++ este . _index < esto . _frames . longitud }; g . SpriteSheetBuilder = c}) (CreateJS || (CreateJS = {})); ( función ( g ) { var  c = función ( un ) { esto . Inicializar (a)}, b = c . Prototipo = nueva  g.DisplayObject ; b . HTMLElement = nula ; b . _style = nula ; b . DisplayObject_initialize = b . inicializar ; b . inicializar = función ( un ) { typeof un == " cadena " && (a = documento . getElemenById (a)); esto . DisplayObject_initialize (); esto . mouseEnabled = false ; si ( este . HTMLElement = a) este . _style = una . estilo , este . _style . posición = " absoluta " , este . _style . transformOrigin = presente . _style . WebkitTransformOrigin = presente . _style . msTransformOrigin = presente . _style . MozTransformOrigin = presente . _style . OTransformOrigin =
" 0% 0% " }; b . isVisible = función () { volver  este . HTMLElement ! = nulo }; b . dibujar = función () { si ( este . HTMLElement ! = nula ) { var un = presente . getConcatenatedMatrix ( este . _matrix ), b = presente . HTMLElement ; b . estilo . opacidad = " " + una . alfa ; b . estilo . visibilidad = esta . visibles ? " Visible " : " oculta " ; b . estilo . transformar = b . estilo . WebkitTransform = b . estilo . OTransform = b . estilo . msTransform = [ " matriz ( " + una . un , una . b , un . c , una . d , una . tx + 0,5 | 0 , ( un . ty + 0,5 | 0 ) + " ) " ]. unirse ( " , " ); b . estilo . MozTransform = [ " matriz ( " + una . Un , una . B , un . C , una . D , ( un . Tx + 0,5 | 0 ) + " px " , ( un . Ty + 0,5 | 0 ) + " px ) " ]. unirse ( " , " ); volver  verdadera }};
b.cache = function () {}; b.uncache = function () {}; b.updateCache = function () {}; b.hitTest = function () {}; b.localToGlobal = function () {}; b.globalToLocal = function () {}; b.localToLocal = function () {}; b.clone = function () {var a = new c; this.cloneProps (a); vuelva a}; b.toString = function () {return "[DOMElement (name =" + + this.name ")]"};! b._tick = function (a) {if (this.htmlElement = null && (this.htmlElement.style.visibility = "oculto" , this.onTick)) this.onTick (a)}; g.DOMElement = c}) (CreateJS || (CreateJS = {})); (función (g) {var c = function () {this.initialize ( )}, b = c.prototype; b.initialize = function () {}; b.getBounds = function () {return nueva g.Rectangle (0,0,0,0)}; b.applyFilter = function () {}; b.toString = function () {return "[Filtro]"}; b.clone = function () {return new c}; g.Filter = c}) (CreateJS || (CreateJS = {})) ; (función (g) {var c = function () {throw "Touch no se pueden crear instancias";}; c.isSupported = function () {return "ontouchstart" en la ventana || window.navigator.msPointerEnabled}; c.enable = function (b, a, g) {if (b || || b.canvas c.isSupported ()!!!) return false; b .__ táctiles = {punteros: {}, multitáctil: una, preventDefault :! g, count: 0}; "ontouchstart" en la ventana c._IOS_enable (b):? window.navigator.msPointerEnabled && c._IE_enable (b); return true}; c._IOS_enable = function (b) {var a = b.canvas ; a.addEventListener ( "touchstart", la función (a) {c._IOS_handleEvent (b,
a)}, false ); un . addEventListener ( " touchmove " , la función ( un ) { c . _IOS_handleEvent (b, a)}, false ); un . addEventListener ( " touchend " , la función ( un ) { c . _IOS_handleEvent (b, a)}, false ); un . addEventListener ( " touchcancel " , la función ( un ) { c . _IOS_handleEvent (b, a)}, false )}; c . _IOS_handleEvent = Función ( b , un ) { b . __touch . preventDefault && una . preventDefault && una . preventDefault (); para ( var c = un . changedTouches , g = un . tipo , d = 0 , e = c . de longitud ; d < e, d ++ ) { var f = c [d], h = f . identificador ; f . dirigirse a == b . lienzo && (g == " touchstart " ? esto . _handleStart (b, h, a, f . pageX , f . pageY ) : g ==
" TouchMove " ? este . _handleMove (b, h, a, f . pageX , f . pageY ) : (g == " touchend " || g == " touchcancel " ) && esto . _handleEnd (b, h, a))}}; c . _IE_enable = Función ( b ) { var un = b . lona ; un . addEventListener ( " MSPointerDown " , la función ( un ) { c . _IE_handleEvent (b, a)}, false ); ventana . addEventListener ( " MSPointerMove " , la función ( un ) { c . _IE_handleEvent (b, a)}, false ); ventana . addEventListener ( " MSPointerUp " , la función ( un ) { c . _IE_handleEvent (b, a)}, false ); ventana . addEventListener ( " MSPointerCancel " , la función ( un ) { c . _IE_handleEvent (b, a)}, false ); si ( b . __touch . preventDefault ) una . estilo . msTouchAction =
" Ninguno " ; b . __touch . activeIDs = {}}; c . _IE_handleEvent = Función ( b , un ) { b . __touch . preventDefault && una . preventDefault && una . preventDefault (); var c = una . tipo , g = una . pointerId , d = b . __touch . activeIDs ; si (c == " MSPointerDown " ) una . srcElemento == b . lienzo && (d [g] = cierto , este . _handleStart (b, g, un, una . pageX , una . pageY )); otra cosa  si (d [g]) si (c == " MSPointerMove " ) presente . _handleMove (b, g, un, una . pageX , una . pageY ); otra cosa  si (c == " MSPointerUp " || c == " MSPointerCancel " ) borrar d [g], este . _handleEnd (b, g, a)}; c . _handleStart = función ( b , una , c , g , d ) { var e = b . __touch ; si ( e . multitouch ||! e . contar ) { var f =
e . punteros ; f [a] || (f [a] = verdadero , e . contar ++ , b . _handlePointerDown (a, c, g, d))}}; c . _handleMove = función ( b , una , c , g , d ) { b . __touch . punteros [a] && b . _handlePointerMove (a, c, g, d)}; c . _handleEnd = función ( b , una , c ) { var g = b . __touch , d = g . punteros ; d [a] && ( g . contar - , b . _handlePointerUp (a, c, cierto ), eliminar d [a])}; g . Toque = c}) (CreateJS || (CreateJS = {}));
